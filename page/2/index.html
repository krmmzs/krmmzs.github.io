<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="233">
<meta property="og:type" content="website">
<meta property="og:title" content="krmmzs">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="krmmzs">
<meta property="og:description" content="233">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="krmmzs">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>krmmzs</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">krmmzs</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/11/LeetCode-47-Permutations-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/11/LeetCode-47-Permutations-II/" class="post-title-link" itemprop="url">LeetCode 47. Permutations II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-11 01:20:16 / Modified: 02:18:12" itemprop="dateCreated datePublished" datetime="2022-11-11T01:20:16+08:00">2022-11-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="leetcode-47.-permutations-ii">LeetCode 47. Permutations II</h1>
<h2 id="main-idea">Main Idea</h2>
<p>暴搜是应该的，搜索顺序以位置为主，而且以位置为搜索顺序能保证字典序</p>
<p>这题需要保证unique</p>
<p>所以我们，如果为每个数编号，那么只要保证枚举的时候各个数相对位置不变 比如三个1分别标记上1 2 3,我们规定只能从编号1枚举到编号3,不能132 保证这样的话，就只会有一个112</p>
<p>举个例子，有数112,可能会产生1(1)1(2)2 和 1(2)1(1)2, 但是我规定了必须吸纳枚举编号1，所以只会有1(1)1(2)2</p>
<p>为了能更好地枚举递增编号的相同value的数，我们需要先排序, 让相同的数相邻</p>
<p>这样操作是至少O(nlogn)的。</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">bool</span>&gt; st;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        path = <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line">        st = <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(nums.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(nums, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (u == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(path);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i ++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (st[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &amp;&amp; nums[i - <span class="number">1</span>] == nums[i] &amp;&amp; !st[i - <span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">                path[u] = nums[i];</span><br><span class="line">                st[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(nums, u + <span class="number">1</span>);</span><br><span class="line">                st[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/11/Why-numbering-should-start-at-zero/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/11/Why-numbering-should-start-at-zero/" class="post-title-link" itemprop="url">Why-numbering should start at zero</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-11 00:06:27 / Modified: 00:35:03" itemprop="dateCreated datePublished" datetime="2022-11-11T00:06:27+08:00">2022-11-11</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="why-numbering-should-start-at-zero">Why-numbering should start at zero</h1>
<p>为什么编号应该从零开始</p>
<p>为了表示自然数2、3、......、12 的子序列，而不使用有害的三点，我们有四种惯例可供选择</p>
<table border="0">
<tbody>
<tr>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">a)</hcfy-result>
</td>
<td width="30">
</td>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">2 ≤ i &lt; 13</hcfy-result>
</td>
</tr>
<tr>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">b)</hcfy-result>
</td>
<td width="30">
</td>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">1 &lt; i ≤ 12</hcfy-result>
</td>
</tr>
<tr>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">c)</hcfy-result>
</td>
<td width="30">
</td>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">2 ≤ i ≤ 12</hcfy-result>
</td>
</tr>
<tr>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">d)</hcfy-result>
</td>
<td width="30">
</td>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">1 &lt; i &lt; 13</hcfy-result>
</td>
</tr>
</tbody>
</table>
<p>是否有理由选择一种惯例而不是另一种？是的，有的。观察到惯例a)和b)有一个优点，即上述界限之间的差异等于子序列的长度是有效的。因此，在任何一个约定中，两个子序列相邻意味着一个子序列的上限等于另一个子序列的下限，这种观察也是有效的。尽管这些观察是有效的，但它们并不能使我们在a)和b)之间做出选择；所以让我们重新开始。</p>
<p>有一个最小的自然数。排除下限--如b)和d)--迫使从最小的自然数开始的子序列的下限进入非自然数的领域。这很难看，所以对于下限，我们更倾向于采用a）和c）中的≤。现在考虑从最小的自然数开始的子序列：加入上限将迫使后者在序列缩减到空数时成为非自然数。这很难看，所以对于上界，我们更倾向于&lt;如a)和d)。我们的结论是a)是首选。</p>
<p>备注 在Xerox PARC开发的编程语言Mesa，在所有四个约定中都有关于整数间隔的特殊符号。使用Mesa的广泛经验表明，使用其他三个约定是笨拙和错误的源头，根据这一经验，现在强烈建议Mesa程序员不要使用后三个可用的功能。我提到这个实验性的证据--为了它的价值--是因为有些人对没有在实践中得到证实的结论感到不舒服。(备注结束）。</p>
<p>当处理一个长度为N的序列时，我们希望用下标来区分其中的元素，下一个棘手的问题是给其起始元素分配什么下标值。遵循惯例a)，当从下标1开始时，可以得到下标范围1≤i&lt;N+1；然而从0开始，可以得到更好的范围0≤i&lt;N。所以我们让我们的序数从0开始：一个元素的序数（下标）等于它在序列中前面的元素数。这个故事的寓意是，我们最好把零看作是一个最自然的数字--在所有这些世纪之后！。</p>
<p>备注 许多编程语言在设计时没有充分注意到这个细节。在FORTRAN中，下标总是从1开始；在ALGOL 60和PASCAL中，惯例c)被采用；最近的SASL又回到了FORTRAN的惯例：SASL中的序列同时也是正整数上的一个函数。遗憾的是! (备注结束。)</p>
<p>上述内容是由最近的一件事引发的，当时我在大学的一位数学同事--不是计算机科学家--在一次情绪爆发中指责一些年轻的计算机科学家 "迂腐"，因为--他们习惯于这样--他们从零开始编号。他把有意识地采用最合理的惯例作为一种挑衅。(同样，"结束...... "的约定也被视为挑衅；但该约定是有用的。我知道有一个学生在一次考试中几乎失败了，因为他默认了问题在第一页的底部结束。） 我认为安东尼-杰伊是对的，他说。"在企业宗教和其他宗教中，异教徒必须被赶出去，不是因为他有可能是错的，而是因为他有可能是对的。"</p>
<table border="0">
<tbody>
<tr>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">Plataanstraat 5</hcfy-result><br><hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">5671 AL NUENEN</hcfy-result><br><hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">荷兰</hcfy-result>
</td>
<td width="80">
</td>
<td>
<hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">1982年8月11日</hcfy-result><br><hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">Edsger W. Dijkstra教授、博士</hcfy-result><br><hcfy-result class="__hcfy__result__result__ __hcfy__result__loaded__">伯勒斯研究员</hcfy-result>
</td>
</tr>
</tbody>
</table>
<hr />
<p>转录者。Kevin Hely.<br />
最后修订于2008年5月2日星期五。</p>
<hr />
<h2 id="reference">Reference</h2>
<p><a target="_blank" rel="noopener" href="https://t.co/bRDeNyo0eD">https://www.cs.utexas.edu/users/EWD/ewd08xx/EWD831.PDF</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/10/CSAPP-chapter02-Representing-and-ManipulatingInformation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/10/CSAPP-chapter02-Representing-and-ManipulatingInformation/" class="post-title-link" itemprop="url">CSAPP-chapter02-Representing and ManipulatingInformation</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-10 18:29:20" itemprop="dateCreated datePublished" datetime="2022-11-10T18:29:20+08:00">2022-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-11 23:16:43" itemprop="dateModified" datetime="2022-11-11T23:16:43+08:00">2022-11-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CSAPP/" itemprop="url" rel="index"><span itemprop="name">CSAPP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="chapter-02-representing-and-manipulatinginformation">chapter 02 Representing and ManipulatingInformation</h1>
<h2 id="information-storage">2.1 Information Storage</h2>
<h3 id="位机器和64位机器-wordsize">32位机器和64位机器 wordsize</h3>
<p>其中long 和 unsigned long 32 位机器上是4字节，64位机器上是8字节。 char* 32 位机器上是4字节，64位机器上是8字节。</p>
<h3 id="变量在内存的存储">变量在内存的存储</h3>
<p>x = 0x01234567 以大端法(Big endian)为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100</span> <span class="number">0x101</span> <span class="number">0x102</span> <span class="number">0x103</span></span><br><span class="line">-------------------------------</span><br><span class="line">...|  <span class="number">01</span> |  <span class="number">23</span> |  <span class="number">45</span> |  <span class="number">67</span> |...</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure>
<p>以小端法(Little endian)为例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x100</span> <span class="number">0x101</span> <span class="number">0x102</span> <span class="number">0x103</span></span><br><span class="line">-------------------------------</span><br><span class="line">...|  <span class="number">67</span> |  <span class="number">45</span> |  <span class="number">23</span> |  <span class="number">01</span> |...</span><br><span class="line">-------------------------------</span><br></pre></td></tr></table></figure>
<h3 id="masking-operations">Masking Operations</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    <span class="number">0x89</span> AB CD EF <span class="number">1110</span> <span class="number">1111</span>(EF)</span><br><span class="line">&amp;   <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> FF <span class="number">1111</span> <span class="number">1111</span>(FF)</span><br><span class="line">    <span class="number">0x00</span> <span class="number">00</span> <span class="number">00</span> EF <span class="number">1110</span> <span class="number">1111</span>(EF)</span><br></pre></td></tr></table></figure>
<p>常用来取出低8位</p>
<p>datalab 会用</p>
<h3 id="shift-operation">Shift Operation</h3>
<p>Logical Right Shift:</p>
<p>Arithmetic Right Shift: pay attention to the biggest bit, if it is 1, will be 1, otherwise 0</p>
<h2 id="interger-representation">2.2 Interger Representation</h2>
<h3 id="preview">Preview</h3>
<p>提一下，这节的证明常使用做差，原因是需要知道两者之间的deta</p>
<h3 id="unsigned-encodings">unsigned Encodings</h3>
<p><img src="/images/csapp-01.png" alt="csapp-01.png" style="zoom:70%;" /></p>
<h3 id="twos-complement-encodings">Two's Complement Encodings</h3>
<p><img src="/images/csapp-02.png" alt="csapp-02.png" style="zoom:70%;" /></p>
<h3 id="maximum-and-minimum-values">Maximum and Minimum Values</h3>
<p><img src="/images/csapp-03.png" alt="csapp-03.png" style="zoom:70%;" /> <img src="/images/csapp-04.png" alt="csapp-04.png" style="zoom:70%;" /> <img src="/images/csapp-05.png" alt="csapp-05.png" style="zoom:70%;" /></p>
<h3 id="special-numeric">Special Numeric</h3>
<p>有符号的-1和无符号的Maximum二进制表示是一样的</p>
<p><img src="/images/csapp-06.png" alt="csapp-06.png" style="zoom:70%;" /></p>
<h3 id="twos-complement-to-unsigned">Two's complement to unsigned</h3>
<p><img src="/images/csapp-07.png" alt="csapp-07.png" style="zoom:70%;" /> <img src="/images/csapp-08.png" alt="csapp-08.png" style="zoom:70%;" /></p>
<p>这里的<span class="math inline">\(T2U_w(x)\)</span> 可以再展开一下，<span class="math inline">\(x + 2 * 2^{w - 1}, x &lt; 0\)</span></p>
<p>表示在最高位转化权值的时候相当于加上了2倍的最高位权值</p>
<h3 id="expanding-the-bit-representation-of-a-number">Expanding the Bit Representation of a Number</h3>
<h4 id="unsigned">Unsigned</h4>
<p><img src="/images/csapp-09.png" alt="csapp-09.png" style="zoom:70%;" /></p>
<h4 id="sign-extension">Sign Extension</h4>
<p><img src="/images/csapp-10.png" alt="csapp-10.png" style="zoom:70%;" /></p>
<p>确保这样的拓展方式可以确保value不变</p>
<p>证明的直观解释是每拓展一位，会减去一个<span class="math inline">\(2^w\)</span>, 加上两个<span class="math inline">\(2^{w-1}\)</span>, 值不变 书中的正确性是由数学归纳法保证的</p>
<h3 id="truncating-unsigned-number">Truncating unsigned number</h3>
<p><img src="/images/csapp-11.png" alt="csapp-11.png" style="zoom:70%;" /></p>
<h3 id="truncating-signed-number">Truncating signed number</h3>
<p><img src="/images/csapp-12.png" alt="csapp-12.png" style="zoom:70%;" /></p>
<p>先B2U, 再U2T</p>
<h2 id="integer-arithmetic">2.3 Integer Arithmetic</h2>
<h3 id="unsigned-addition">Unsigned Addition</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">char</span> a = <span class="number">255</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> c = a + b;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;c=%d&quot;</span>, c);</span><br></pre></td></tr></table></figure>
<p>will get: c = 0</p>
<p>unsigned char Minimum:0, Maximum:255</p>
<p><img src="/images/csapp-13.png" alt="csapp-13.png" style="zoom:70%;" /> <img src="/images/csapp-14.png" alt="csapp-14.png" style="zoom:70%;" /></p>
<h3 id="detecting-overflow-of-unsigned-addition">Detecting Overflow of Unsigned Addition</h3>
<p><img src="/images/csapp-15.png" alt="csapp-15.png" style="zoom:70%;" /></p>
<h3 id="additive-inverse">Additive Inverse</h3>
<p>这块书上感觉有点难理解</p>
<p>逆元，Abelian Group</p>
<p>在数学里逆元是指一个数乘以它的逆元等于1，即a * a^-1 = 1 相反数是指一个数加上它的相反数等于0，即a + (-a) = 0 这两者差不多</p>
<p>但是在这里因为无符号符号数的存在，所以逆元不一定是相反数</p>
<p>当x, x' 满足 <span class="math inline">\(0 &lt;= x &lt; 2^w, 0 &lt;= x&#39; &lt; 2^w\)</span>, 构造 <span class="math inline">\(x + x&#39; = 2^w\)</span> 因为溢出，得到<span class="math inline">\(x + x&#39; = 2^w = 0\)</span></p>
<p><img src="/images/csapp-16.png" alt="csapp-16.png" style="zoom:70%;" /></p>
<h3 id="twos-complement-addition">Two's Complement Addition</h3>
<p><img src="/images/csapp-17.png" alt="csapp-17.png" style="zoom:70%;" /></p>
<h4 id="positive-overflow">Positive Overflow</h4>
<p><img src="/images/csapp-18.png" alt="csapp-18.png" style="zoom:70%;" /></p>
<h4 id="negative-overflow">Negative Overflow</h4>
<p><img src="/images/csapp-19.png" alt="csapp-19.png" style="zoom:70%;" /></p>
<h3 id="how-to-judge-overflow">How to judge overflow</h3>
<ol type="1">
<li>x &gt;= 0, y &gt;= 0, x +y &lt; 0 -&gt; Positive Overflow</li>
<li>x &lt; 0, y &lt; 0, x + y &gt;= 0 -&gt; Negative Overflow</li>
</ol>
<h3 id="twos-complement-negation">Two's Complement Negation</h3>
<p>感觉没有什么用</p>
<p><img src="/images/csapp-20.png" alt="csapp-20.png" style="zoom:70%;" /></p>
<h3 id="unsigned-multiplication">Unsigned Multiplication</h3>
<p>两个w位数相乘，结果是2w位数 但是只有w位是有效的，需要截断 <span class="math inline">\((x * y) \bmod 2^w\)</span></p>
<h3 id="twos-complement-multiplication">Two's Complement Multiplication</h3>
<p><span class="math inline">\(U2T_w((x * y) \bmod 2^w)\)</span></p>
<h3 id="multiplying-by-constants">Multiplying by Constants</h3>
<p><img src="/images/csapp-21.png" alt="csapp-21" style="zoom:70%;" /></p>
<p>A Ex: <img src="/images/csapp-22.png" alt="csapp-22" style="zoom:70%;" /></p>
<h3 id="dividing-by-powers-of-2">Dividing by Powers of 2</h3>
<p><img src="/images/csapp-23.png" alt="csapp-23" style="zoom:70%;" /></p>
<p>这里是已知要进行k次位移，然后对x即将进行的位移进行基于权重的位置分割</p>
<p>让x = x1 * 2^k + x2, x1为高w-k位，x2为低k位</p>
<p>做位移之后可以得到</p>
<p>x &gt;&gt; k = x1</p>
<p><img src="/images/csapp-24.png" alt="csapp-24" style="zoom:70%;" /></p>
<p>但是这样位移得到的是数学上的向下取整，而不是向上取整</p>
<p>向上取整在计算机中可以表述为向0取整</p>
<p><img src="/images/csapp-25.png" alt="csapp-25" style="zoom:70%;" /></p>
<p>为了能够向0取整</p>
<blockquote>
<p>We can correct for the improper rounding that occurs when a negative numberis shifted right by “biasing” the value before shifting.</p>
</blockquote>
<p><img src="/images/csapp-26.png" alt="csapp-26" style="zoom:70%;" /></p>
<p><span class="math inline">\(bias = (1 &lt;&lt; k) - 1\)</span></p>
<p>推导见书本</p>
<h2 id="excercise">Excercise</h2>
<p>2.42 我觉得很nice</p>
<blockquote>
<p>Practice Problem 2.42(solution page 192) Write a functiondiv16that returns the valuex/16for integer argumentx. Your function should not use division, modulus, multiplication, any conditionals (if or ? : ), any comparison operators (e.g.,&lt;,&gt;,or==), or any loops. You may assume that data typeintis 32 bits long and uses a two’s-complement representation, and that right shifts are performed arithmetically.</p>
</blockquote>
<p>通过前面的推导我们已经能够得到能够正确得到期望值的操作： <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(x &lt; <span class="number">0</span> ? x + (<span class="number">1</span> &lt;&lt; k) - <span class="number">1</span> : x) &gt;&gt; k</span><br></pre></td></tr></table></figure></p>
<p>这里希望写一个div16, 也就是k为4的情况</p>
<p>所以这里的bias就是15</p>
<p>如何知道x的正负?</p>
<p>可以通过二进制的最高位来判断，对应的操作是x &gt;&gt; 31</p>
<p>但是这题没法用if,得通过&amp;和|来构造得到bias</p>
<p>因为位移不会改变位数w, x &gt;&gt; 31的结果仍然是w位的，如果最高位为1,那么会得到全32位的1,反之会得到全32位的0</p>
<p>&amp;上0xF就可以得到0xF或者0， 也就是对应的bias</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">div16</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="type">int</span> bias = (x &gt;&gt; <span class="number">31</span>) &amp; <span class="number">0xF</span>;</span><br><span class="line">    <span class="keyword">return</span> (x + bias) &gt;&gt; <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="floating-point">Floating Point</h2>
<h3 id="floating-point-type">Floating Point Type</h3>
<p><img src="/images/csapp-27.png" alt="csapp-27" style="zoom:70%;" /></p>
<p>这里书翻译成规格化愣是没看懂...</p>
<h3 id="floating-point-representation">Floating Point Representation</h3>
<p><img src="/images/csapp-28.png" alt="csapp-28" style="zoom:70%;" /></p>
<p>这个公式 is <strong>important</strong></p>
<p>这里颜色做了区分</p>
<p>C语言中的float类型是32位的</p>
<blockquote>
<p>float is a 32-bit IEEE 754 single precision Floating Point Number – 1 bit for the sign, 8 bits for the exponent, and 23* for the value.</p>
</blockquote>
<h3 id="normalized">Normalized</h3>
<p><img src="/images/csapp-29.png" alt="csapp-29" style="zoom:70%;" /></p>
<p>这里的M是1+... &gt;= 1的</p>
<p>这一块感觉都只是解释如何表示，没有讲为什么会这么设计</p>
<p><img src="/images/csapp-30.png" alt="csapp-30" style="zoom:70%;" /></p>
<h3 id="denormalized">Denormalized</h3>
<p><img src="/images/csapp-31.png" alt="csapp-31" style="zoom:70%;" /></p>
<p>第一个用途是用来表示0</p>
<p>IEEE 这么表示有+0和-0, 是为了在1/0的时候能够区分出来+无穷和-无穷</p>
<p><img src="/images/csapp-32.png" alt="csapp-32" style="zoom:70%;" /></p>
<p>第二个用途是用来表示非常接近0的数</p>
<p>注意，这里<span class="math inline">\(E = 1 - Bias\)</span> 是确定好了的</p>
<p>这么确定的原因在图2-35给出了最大的非规格数和最小的规格化数之间的平滑转变</p>
<h3 id="infinity">Infinity</h3>
<p><img src="/images/csapp-33.png" alt="csapp-33" style="zoom:70%;" /></p>
<h3 id="nan">NaN</h3>
<p><img src="/images/csapp-34.png" alt="csapp-34" style="zoom:70%;" /></p>
<p>这四种情况的用途最好用 <strong>Figure 2.34</strong> 来记忆</p>
<h3 id="int-and-float-conversion">int and float conversion</h3>
<p><img src="/images/csapp-35.png" alt="csapp-35" style="zoom:70%;" /></p>
<p><img src="/images/csapp-36.png" alt="csapp-36" style="zoom:70%;" /></p>
<p><img src="/images/csapp-37.png" alt="csapp-37" style="zoom:70%;" /></p>
<p><img src="/images/csapp-38.png" alt="csapp-38" style="zoom:70%;" /></p>
<h3 id="rounding">Rounding</h3>
<p>因为不能精确表示，所以需要进行舍入</p>
<p>上下和零舍入都进行过讨论了，他们会产生 <strong>guaranteed bound</strong></p>
<h4 id="round-to-even">Round to even</h4>
<p><img src="/images/csapp-39.png" alt="csapp-39" style="zoom:70%;" /></p>
<p><img src="/images/csapp-40.png" alt="csapp-40" style="zoom:70%;" /></p>
<h3 id="floating-point-operations">Floating Point Operations</h3>
<p><img src="/images/csapp-41.png" alt="csapp-41" style="zoom:70%;" /></p>
<p>这里主要是讲浮点数的<code>Rounding</code>造成不支持结合律和交换律(这个是由结合律和交换律的定义决定的)</p>
<h3 id="floating-point-in-c">Floating Point in C</h3>
<p>这里就看书就好了，讲的很清楚</p>
<p>其中会被舍入是因为精度问题，从精度高的往精度低的转换的时候会被舍入</p>
<h2 id="tips">Tips</h2>
<p>Pay attention to Tmin, his opposite number is itself Tmin: x = 1000000000, opposite: -x=~x + 1 = 0111111111 + 1 = 1000000000</p>
<h2 id="key-example">Key example</h2>
<p><strong>重点示例</strong><a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du#xue-xi-fang-shi#zhong-dian-shi-li"></a></p>
<h3 id="例1-带符号数产生意外结果的例子"><strong>例1:</strong> 带符号数产生意外结果的例子。</h3>
<p>这个例子会造成无限循环，因为sizeof会返回unsigned int 类型，由此带来的结果是，i - sizeof(char)这个表达式的求值结果将会是 unsigned int (隐式转换 !!)，无符号数 0 减 1 会变成 0xFFFFFFFF，从而产生无限循环，有时候你需要特别留心这种不经意的错误 !</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Demo_4</span></span><br><span class="line"><span class="type">int</span> n = <span class="number">10</span>, i; </span><br><span class="line"><span class="keyword">for</span> (i = n - <span class="number">1</span> ; i - <span class="built_in">sizeof</span>(<span class="type">char</span>) &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;i: 0x%x\n&quot;</span>,i);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="number">-1</span> &gt; <span class="number">0U</span>)                     <span class="comment">// 神奇的算术!! </span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;You Surprised me!\n&quot;</span>); </span><br></pre></td></tr></table></figure>
<h3 id="例2-freebsd-kernal-code"><strong>例2:</strong> freeBSD kernal code</h3>
<p>以下是2002年的freeBSD内核的部分代码，其中包含了漏洞，假设恶意人员将负值作为maxlen传入这个函数，有发生什么情况？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> KSIZE 1024</span></span><br><span class="line"><span class="type">char</span> kbuf[KSIZE];</span><br><span class="line"><span class="comment">/* Copy at most maxlen bytes from kernel region to user buffer */</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">copy_from_kernel</span><span class="params">(<span class="type">void</span> *user_dest, <span class="type">int</span> maxlen)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> len = KSIZE &lt; maxlen ? KSIZE : maxlen;</span><br><span class="line">    <span class="built_in">memcpy</span>(user_dest, kbuf, len);</span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Declaration of library function memcpy */</span></span><br><span class="line"><span class="function"><span class="type">void</span> *<span class="title">memcpy</span><span class="params">(<span class="type">void</span> *dest, <span class="type">void</span> *src, <span class="type">size_t</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Malicious Usage */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">getstuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> mybuf[MSIZE];</span><br><span class="line">    <span class="built_in">copy_from_kernel</span>(mybuf, <span class="number">-512</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似的，请参照书本 p69：XOR库中的乘法溢出漏洞，思考对应的解决方案 (p70：练习题2.37)</p>
<h3 id="例3-拓展-给定一个有序的整型数组请编程实现二分查找算法"><strong>例3 (拓展):</strong> 给定一个有序的整型数组，请编程实现二分查找算法。</h3>
<p>高德纳在《计算机程序设计的艺术》指出，虽然早在1946年就有人将二分查找的方法公诸于世，但直到1962年才有人写出没有bug的二分查找程序，可见，写一个安全的代码并不容易，你是不是一不小心就写出像下面这样的二分查找代码了？</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> len, <span class="type">int</span> key)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> low = <span class="number">0</span>; </span><br><span class="line">    <span class="type">int</span> high = len - <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( low &lt;= high ) &#123;</span><br><span class="line">        <span class="type">int</span> mid = (low + high)/<span class="number">2</span>;   <span class="comment">// 提示：这里有溢出Bug！</span></span><br><span class="line">        <span class="keyword">if</span> (a[mid] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (key &lt; a[mid]) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例4-拓展-浮点数运算">例4 (拓展): 浮点数运算</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 有问题的版本 </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) sum += i + <span class="number">1</span>;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;Sum: %f\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 + 2 + 3 + … + 10000 = 10000 * (10000 + 1) / 2 = 50005000 ?</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 修正的版本</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">float</span> sum = <span class="number">0.0f</span>, corr = <span class="number">0.0f</span>; <span class="comment">/* corrective value for rounding error */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">      <span class="type">float</span> y = (i + <span class="number">1</span>) - corr; <span class="comment">/* add the correction to specific item */</span></span><br><span class="line">      <span class="type">float</span> t = sum + y; <span class="comment">/* bits might be lost */</span></span><br><span class="line">      corr = (t - sum) - y; <span class="comment">/* recover lost bits */</span></span><br><span class="line">      sum = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Sum: %f\n&quot;</span>, sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="例5-拓展"><strong>例5 (拓展):</strong></h3>
<p>信息的处理（你会如何删除一个单向链表的一个结点，假设节点必定在list之中）</p>
<p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cs411y7GQ?from=search&amp;seid=13695301827862285580">Linus Torvalds 2016年TED采访</a>，14:26开始，拿出两个单向链表操作为例， 说明了什么是有品位的程序。</p>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZINEIzoQqj1b-PFoi8%2F-MZINj8YXqiKiWGGNDO-%2Fimage.png?alt=media&amp;token=716412b6-e86b-4940-9c2d-6d733e456037" /></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初学者版本</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove_list_node</span><span class="params">(List *list, Node *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *prev = <span class="literal">NULL</span>;</span><br><span class="line">    Node *cur = list-&gt;head;</span><br><span class="line">    <span class="comment">// Walk the list</span></span><br><span class="line">    <span class="keyword">while</span> (cur != target) &#123;</span><br><span class="line">        prev = cur;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Remove the target by updating the head or the previous node.</span></span><br><span class="line">    <span class="keyword">if</span> (!prev)</span><br><span class="line">        list-&gt;head = target-&gt;next;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        prev-&gt;next = target-&gt;next;</span><br><span class="line">&#125;```</span><br><span class="line"></span><br><span class="line">![](https:<span class="comment">//1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZIj7I8WD6yGsKN6BU5%2F-MZIjQ2a799ldRuUOQox%2Fimage.png?alt=media&amp;token=0791167b-70a5-4aef-89ab-d0a6d62a7b92)</span></span><br><span class="line"></span><br><span class="line">```cpp</span><br><span class="line"><span class="comment">// 有品位的版本，消除特例，简单优雅的代码</span></span><br><span class="line"><span class="type">void</span> <span class="built_in">remove_list_node</span>(List *list, Node *target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// The &quot;indirect&quot; pointer points to the *address*</span></span><br><span class="line">    <span class="comment">// of the thing we&#x27;ll update.</span></span><br><span class="line">    Node **indirect = &amp;list-&gt;head;</span><br><span class="line">    <span class="comment">// Walk the list, looking for the thing that </span></span><br><span class="line">    <span class="comment">// points to the node we want to remove.</span></span><br><span class="line">    <span class="keyword">while</span> (*indirect != target)</span><br><span class="line">        indirect = &amp;(*indirect)-&gt;next;</span><br><span class="line">    *indirect = target-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://1484576603-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-MV9vJFv4kmvRLgEog6g%2F-MZIj7I8WD6yGsKN6BU5%2F-MZIki5iyCQRKbRbJZMd%2Fimage.png?alt=media&amp;token=f86e6e43-ee60-46f0-9fb5-0108f575bddd" /></p>
<h2 id="references">References</h2>
<ul>
<li>九曲阑干用3b1b引擎做的图</li>
<li><a target="_blank" rel="noopener" href="https://fengmuzi2003.gitbook.io/csapp3e/di-er-zhang-zhong-dian-jie-du">CSAPP重点解读</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/09/How-to-config-ccls-in-Neovim-lsp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/09/How-to-config-ccls-in-Neovim-lsp/" class="post-title-link" itemprop="url">How to config ccls in Neovim lsp</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-09 21:57:04 / Modified: 22:08:16" itemprop="dateCreated datePublished" datetime="2022-11-09T21:57:04+08:00">2022-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Neovim/" itemprop="url" rel="index"><span itemprop="name">Neovim</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Neovim/LSP/" itemprop="url" rel="index"><span itemprop="name">LSP</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="how-to-config-ccls-in-neovim-lsp">How to config ccls in Neovim lsp</h1>
<h2 id="ccls">ccls</h2>
<p>ccls is a C/C++/ObjC language server supporting cross references, hierarchies, completion and semantic highlighting.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/MaskRay/ccls/wiki">ccls wiki</a></p>
<h2 id="nvim-lspconfig">nvim-lspconfig</h2>
<p>nvim-lspconfig is a collection of common configurations for the Nvim LSP client.</p>
<p><a target="_blank" rel="noopener" href="https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md#ccls">nvim-lspconfig ccls</a></p>
<h2 id="config-file">config file</h2>
<p>all see my <a target="_blank" rel="noopener" href="https://github.com/krmmzs/.dotfiles/tree/master/nvim/.config/nvim">dotfile</a></p>
<p>lsp/init.lua <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">require</span>(<span class="string">&quot;mzs.lsp.lsp-installer&quot;</span>)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>lsp/lsp-installer.lua <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="comment">-- Register a handler that will be called for all installed servers.</span></span><br><span class="line"><span class="comment">-- Alternatively, you may also register handlers on specific server instances instead (see example below).</span></span><br><span class="line">lsp_installer.on_server_ready(<span class="function"><span class="keyword">function</span><span class="params">(server)</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">if</span> server.name == <span class="string">&quot;ccls&quot;</span> <span class="keyword">then</span></span><br><span class="line">        <span class="keyword">local</span> ccls_opts = <span class="built_in">require</span>(<span class="string">&quot;mzs.lsp.settings.ccls&quot;</span>)</span><br><span class="line">        opts = vim.tbl_deep_extend(<span class="string">&quot;force&quot;</span>, ccls_opts, opts)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">-- This setup() function is exactly the same as lspconfig&#x27;s setup function.</span></span><br><span class="line">    <span class="comment">-- Refer to https://github.com/neovim/nvim-lspconfig/blob/master/doc/server_configurations.md</span></span><br><span class="line">    server:setup(opts)</span><br><span class="line"><span class="keyword">end</span>)</span><br></pre></td></tr></table></figure></p>
<p>lsp/settings/ccls.lua <figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">    init_options = &#123;</span><br><span class="line">        compilationDatabaseDirectory = <span class="string">&quot;build&quot;</span>;</span><br><span class="line">        index = &#123;</span><br><span class="line">            threads = <span class="number">0</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        clang = &#123;</span><br><span class="line">            excludeArgs = &#123; <span class="string">&quot;-frounding-math&quot;</span>&#125; ;</span><br><span class="line">            extraArgs = &#123; <span class="string">&quot;-Wall&quot;</span>, <span class="string">&quot;-std=c++17&quot;</span>, <span class="string">&quot;-g&quot;</span> &#125;; <span class="comment">-- support C++17</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/09/How-to-sum-up-elements-of-a-Cpp-vector/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/09/How-to-sum-up-elements-of-a-Cpp-vector/" class="post-title-link" itemprop="url">How to sum up elements of a Cpp vector</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-09 21:39:51 / Modified: 21:58:47" itemprop="dateCreated datePublished" datetime="2022-11-09T21:39:51+08:00">2022-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="c03">C++03</h2>
<ol type="1">
<li><p>Classic for loop:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(std::vector&lt;<span class="type">int</span>&gt;::iterator it = vector.<span class="built_in">begin</span>(); it != vector.<span class="built_in">end</span>(); ++it)</span><br><span class="line">    sum_of_elems += *it;</span><br></pre></td></tr></table></figure></li>
<li><p>Using a standard algorithm:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">    </span><br><span class="line">sum_of_elems = std::<span class="built_in">accumulate</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Important Note:</strong> The last argument's type is used not just for the initial value, but for <em>the type of the result</em> as well. If you put an int there, it will accumulate ints even if the vector has float. If you are summing floating-point numbers, change <code>0</code> to <code>0.0</code> or <code>0.0f</code> (<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3221812/how-to-sum-up-elements-of-a-c-vector#comment20983332_3221813">thanks to nneonneo</a>). See also the C++11 solution below.</p></li>
</ol>
<h2 id="c11-and-higher">C++11 and higher</h2>
<ol start="2" type="1">
<li><ol start="2" type="a">
<li>Automatically keeping track of the vector type even in case of future changes:</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">    </span><br><span class="line">sum_of_elems = std::<span class="built_in">accumulate</span>(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(),</span><br><span class="line">                               <span class="keyword">decltype</span>(vector)::<span class="built_in">value_type</span>(<span class="number">0</span>));</span><br></pre></td></tr></table></figure></li>
<li><p>Using <code>std::for_each</code>:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::for_each(vector.<span class="built_in">begin</span>(), vector.<span class="built_in">end</span>(), [&amp;] (<span class="type">int</span> n) &#123;</span><br><span class="line">    sum_of_elems += n;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><p>Using a range-based for loop (<a target="_blank" rel="noopener" href="https://stackoverflow.com/a/3224488/11573842">thanks to Roger Pate</a>):</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; n : vector)</span><br><span class="line">    sum_of_elems += n;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="c17-and-above">C++17 and above</h2>
<ol start="5" type="1">
<li><p>Using <code>std::reduce</code> which also takes care of the result type, e.g if you have <code>std::vector&lt;int&gt;</code>, you get <code>int</code> as result. If you have <code>std::vector&lt;float&gt;</code>, you get <code>float</code>. Or if you have <code>std::vector&lt;std::string&gt;</code>, you get <code>std::string</code> (all strings concatenated). Interesting, isn't it?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> result = std::<span class="built_in">reduce</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>There are <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/algorithm/reduce">other overloads of this function</a> which you can run even parallelly, in case if you have a large collection and you want to get the result quickly.</p></li>
</ol>
<h2 id="references">References</h2>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/3221812/how-to-sum-up-elements-of-a-c-vector">How to sum up elements of a C++ vector?</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/09/%E7%AC%AC2%E7%AB%A0%E8%AF%AD%E8%A8%80%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E5%BC%BA%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/09/%E7%AC%AC2%E7%AB%A0%E8%AF%AD%E8%A8%80%E5%8F%AF%E7%94%A8%E6%80%A7%E7%9A%84%E5%BC%BA%E5%8C%96/" class="post-title-link" itemprop="url">第2章语言可用性的强化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-09 20:15:44" itemprop="dateCreated datePublished" datetime="2022-11-09T20:15:44+08:00">2022-11-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-10 00:26:31" itemprop="dateModified" datetime="2022-11-10T00:26:31+08:00">2022-11-10</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/Modern-C-Tutorial/" itemprop="url" rel="index"><span itemprop="name">Modern C++ Tutorial</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="语言可用性的强化">02语言可用性的强化</h1>
<h2 id="overview">Overview</h2>
<ul>
<li><a href="#2.1-常量">2.1常量</a>
<ul>
<li><a href="#nullptr">nullptr</a></li>
<li><a href="#constexpr">constexpr</a></li>
</ul></li>
<li><a href="">2.2变量及其初始化</a></li>
</ul>
<h2 id="常量">2.1 常量</h2>
<h3 id="nullptr"><code>nullptr</code></h3>
<p>C++11 引入了 <code>nullptr</code> 关键字，专门用来区分空指针、<code>0</code>。</p>
<p><code>nullptr</code> 的类型为 <code>nullptr_t</code>，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p>
<p>Ex: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;type_traits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span></span>;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="type">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), std::<span class="type">nullptr_t</span>&gt;::value)</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">foo</span>(<span class="number">0</span>);          <span class="comment">// 调用 foo(int)</span></span><br><span class="line">    <span class="comment">// foo(NULL);    // 该行不能通过编译</span></span><br><span class="line">    <span class="built_in">foo</span>(<span class="literal">nullptr</span>);    <span class="comment">// 调用 foo(char*)</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">char</span> *)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(char*) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(<span class="type">int</span> i)</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;foo(int) is called&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里用到了<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/decltype">decltype</a> 和 <a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/types/is_same">std::is_same</a></p>
<p>Output: <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo(int) is called</span><br><span class="line">foo(char*) is called</span><br></pre></td></tr></table></figure></p>
<p>从输出中我们可以看出，<code>NULL</code> 不同于 <code>0</code> 与 <code>nullptr</code>。所以，请养成直接使用 <code>nullptr</code>的习惯。</p>
<h3 id="constexpr"><code>constexpr</code></h3>
<p>C++ 本身已经具备了常量表达式的概念，比如 <code>1+2</code>, <code>3*4</code> 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> LEN 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">len_foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">len_foo_constexpr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">char</span> arr_1[<span class="number">10</span>];                      <span class="comment">// 合法</span></span><br><span class="line">    <span class="type">char</span> arr_2[LEN];                     <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> len = <span class="number">10</span>;</span><br><span class="line">    <span class="comment">// char arr_3[len];                  // 非法</span></span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> len_2 = len + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">constexpr</span> <span class="type">int</span> len_2_constexpr = <span class="number">1</span> + <span class="number">2</span> + <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// char arr_4[len_2];                // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_4[len_2_constexpr];         <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// char arr_5[len_foo()+5];          // 非法</span></span><br><span class="line">    <span class="type">char</span> arr_6[<span class="built_in">len_foo_constexpr</span>() + <span class="number">1</span>]; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 1, 1, 2, 3, 5, 8, 13, 21, 34, 55</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">fibonacci</span>(<span class="number">10</span>) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子中，<code>char arr_4[len_2]</code> 可能比较令人困惑，因为 <code>len_2</code> 已经被定义为了常量。为什么 <code>char arr_4[len_2]</code> 仍然是非法的呢？<strong>这是因为 C++ 标准中数组的长度必须是一个常量表达式，而对于 <code>len_2</code> 而言，这是一个 <code>const</code> 常数，而不是一个常量表达式</strong>，因此（即便这种行为在大部分编译器中都支持，但是）它是一个非法的行为，我们需要使用接下来即将介绍的 C++11 引入的 <code>constexpr</code> 特性来解决这个问题；而对于 <code>arr_5</code> 来说，C++98 之前的编译器无法得知 <code>len_foo()</code> 在运行期实际上是返回一个常数，这也就导致了非法的产生。</p>
<h4 id="main">Main</h4>
<p>C++11 提供了 <code>constexpr</code> 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证 <code>len_foo</code> 在编译期就应该是一个常量表达式。</p>
<p>此外，<code>constexpr</code> 修饰的函数可以使用递归：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>)+<span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>C++14</code> 开始，<code>constexpr</code> 函数可以在内部使用局部变量、循环和分支等简单语句，例如下面的代码在 C++11 的标准下是不能够通过编译的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为此，我们可以写出下面这类简化的版本来使得函数从 C++11 开始即可用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">fibonacci</span><span class="params">(<span class="type">const</span> <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : <span class="built_in">fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">fibonacci</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="变量及其初始化">2.2变量及其初始化</h2>
<h3 id="ifswitch变量声明强化">if/switch变量声明强化</h3>
<p>C++17能在 <code>if</code> 和 <code>switch</code> 语句中声明一个临时的变量</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 c++17 之前</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr = <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 需要重新定义一个新的变量</span></span><br><span class="line">    <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr2 = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    <span class="keyword">if</span> (itr2 != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        *itr2 = <span class="number">4</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将输出 1, 4, 3, 4</span></span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator element = vec.<span class="built_in">begin</span>(); element != vec.<span class="built_in">end</span>(); </span><br><span class="line">        ++element)</span><br><span class="line">        std::cout &lt;&lt; *element &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C++17later(like go): <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;::iterator itr = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="number">3</span>);</span><br><span class="line">    itr != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    *itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="初始化列表">初始化列表</h3>
<p>C++11 首先把初始化列表的概念绑定到类型上，称其为 <code>std::initializer_list</code>，允许构造函数或其他函数像参数一样使用初始化列表，这就为类对象的初始化与普通数组和 POD 的初始化方法提供了统一的桥梁，例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">             it != list.<span class="built_in">end</span>(); ++it)</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// after C++11</span></span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (std::vector&lt;<span class="type">int</span>&gt;::iterator it = magicFoo.vec.<span class="built_in">begin</span>(); </span><br><span class="line">        it != magicFoo.vec.<span class="built_in">end</span>(); ++it) </span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>初始化列表除了用在对象构造上，还能将其作为普通函数的形参，例如： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(std::initializer_list&lt;<span class="type">int</span>&gt; list)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (std::initializer_list&lt;<span class="type">int</span>&gt;::iterator it = list.<span class="built_in">begin</span>();</span><br><span class="line">            it != list.<span class="built_in">end</span>(); ++it) vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">magicFoo.<span class="built_in">foo</span>(&#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>其次，C++11 还提供了统一的语法来初始化任意的对象，例如：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Foo foo2 &#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="结构化绑定">结构化绑定</h3>
<p>结构化绑定提供了类似其他语言中提供的多返回值的功能。在容器一章中，我们会学到 C++11 新增了 <code>std::tuple</code> 容器用于构造一个元组，进而囊括多个返回值。但缺陷是，C++11/14 并没有提供一种简单的方法直接从元组中拿到并定义元组中的元素，尽管我们可以使用 <code>std::tie</code> 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p>
<p>C++17 完善了这一设定，给出的结构化绑定可以让我们写出这样的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::tuple&lt;<span class="type">int</span>, <span class="type">double</span>, std::string&gt; <span class="title">f</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">make_tuple</span>(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> [x, y, z] = <span class="built_in">f</span>();</span><br><span class="line">    std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="类型推导">2.3类型推导</h2>
<p>C++11 引入了 <code>auto</code> 和 <code>decltype</code> 这两个关键字实现了类型推导，让编译器来操心变量的类型。这使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p>
<h3 id="auto"><code>auto</code></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 之前</span></span><br><span class="line"><span class="comment">// 由于 cbegin() 将返回 vector&lt;int&gt;::const_iterator</span></span><br><span class="line"><span class="comment">// 所以 it 也应该是 vector&lt;int&gt;::const_iterator 类型</span></span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::const_iterator it = vec.<span class="built_in">cbegin</span>(); it != vec.<span class="built_in">cend</span>(); ++it)</span><br></pre></td></tr></table></figure>
<p>而有了 auto 之后可以：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;initializer_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MagicFoo</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; vec;</span><br><span class="line">    <span class="built_in">MagicFoo</span>(std::initializer_list&lt;<span class="type">int</span>&gt; list) &#123;</span><br><span class="line">        <span class="comment">// 从 C++11 起, 使用 auto 关键字进行类型推导</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> it = list.<span class="built_in">begin</span>(); it != list.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(*it);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = magicFoo.vec.<span class="built_in">begin</span>(); it != magicFoo.vec.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot;, &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一些其他的常见用法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>;              <span class="comment">// i 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> arr = <span class="keyword">new</span> <span class="built_in">auto</span>(<span class="number">10</span>); <span class="comment">// arr 被推导为 int *</span></span><br></pre></td></tr></table></figure>
<p>从 C++ 20 起，<code>auto</code> 甚至能用于函数传参，考虑下面的例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line">std::cout &lt;&lt; <span class="built_in">add</span>(i, j) &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：<code>auto</code> 还不能用于推导数组类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;; <span class="comment">// 错误, 无法推导数组元素类型</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.6</span>.<span class="keyword">auto</span>.cpp:<span class="number">30</span>:<span class="number">19</span>: error: <span class="string">&#x27;auto_arr2&#x27;</span> declared as array of <span class="string">&#x27;auto&#x27;</span></span><br><span class="line">    <span class="keyword">auto</span> auto_arr2[<span class="number">10</span>] = &#123;arr&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="decltype"><code>decltype</code></h3>
<p><code>decltype</code> 关键字是为了解决 <code>auto</code> 关键字只能对变量进行类型推导的缺陷而出现的。它的用法和 <code>typeof</code> 很相似：</p>
<p><code>decltype</code> 用于推断类型的用法，下面这个例子就是判断上面的变量 <code>x, y, z</code> 是否是同一类型：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">int</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == int&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="type">float</span>&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type x == float&quot;</span> &lt;&lt; std::endl;</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(x), <span class="keyword">decltype</span>(z)&gt;::value)</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;type z == type x&quot;</span> &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>其中，<code>std::is_same&lt;T, U&gt;</code> 用于判断 <code>T</code> 和 <code>U</code> 这两个类型是否相等。输出结果为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type x == int</span><br><span class="line">type z == type x</span><br></pre></td></tr></table></figure>
<h3 id="尾返回类型推导">尾返回类型推导</h3>
<h4 id="main-1">Main</h4>
<p>C++11 引入了一个叫做尾返回类型（trailing return type），利用 auto 关键字将返回类型后置 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add2</span><span class="params">(T x, U y)</span> -&gt; <span class="title">decltype</span><span class="params">(x+y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C++14 开始是可以直接让普通函数具备返回值推导 <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>传统： <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span></span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：typename 和 class 在模板参数列表中没有区别，在 typename 这个关键字出现之前，都是使用 class 来定义模板参数的。但在模板中定义有<a target="_blank" rel="noopener" href="https://en.cppreference.com/w/cpp/language/dependent_name#The_typename_disambiguator_for_dependent_names">嵌套依赖类型</a>的变量时，需要用 typename 消除歧义 <a target="_blank" rel="noopener" href="https://krmmzs.com/2022/10/27/Cpp/Accelerated-Cpp/Accelerated-Cpp-chapter08/#typename">my blog typename</a></p>
</blockquote>
<p>可以检查一下类型推导是否正确：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// after c++11</span></span><br><span class="line"><span class="keyword">auto</span> w = <span class="built_in">add2</span>&lt;<span class="type">int</span>, <span class="type">double</span>&gt;(<span class="number">1</span>, <span class="number">2.0</span>);</span><br><span class="line"><span class="keyword">if</span> (std::is_same&lt;<span class="keyword">decltype</span>(w), <span class="type">double</span>&gt;::value) &#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;w is double: &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">std::cout &lt;&lt; w &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">// after c++14</span></span><br><span class="line"><span class="keyword">auto</span> q = <span class="built_in">add3</span>&lt;<span class="type">double</span>, <span class="type">int</span>&gt;(<span class="number">1.0</span>, <span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; <span class="string">&quot;q: &quot;</span> &lt;&lt; q &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<h3 id="decltypeauto">decltype(auto)</h3>
<p>C++14</p>
<p><a target="_blank" rel="noopener" href="https://stackoverflow.com/a/24109800/14787331">stackoverflow</a></p>
<p>简单来说，<code>decltype(auto)</code> 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的指定 <code>decltype</code> 的参数表达式。考虑看下面的例子，当我们需要对下面两个函数进行封装时：</p>
<p>在 C++11 中，封装实现是如下形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::string <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::string&amp; <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而有了 <code>decltype(auto)</code>，我们可以让编译器完成这一件烦人的参数转发：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup1</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">decltype</span>(<span class="keyword">auto</span>) <span class="title">look_up_a_string_2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">lookup2</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="控制流">2.4控制流</h2>
<p>wait...</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/09/%E7%AC%AC1%E7%AB%A0-%E8%BF%88%E5%90%91%E7%8E%B0%E4%BB%A3-Cpp/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/09/%E7%AC%AC1%E7%AB%A0-%E8%BF%88%E5%90%91%E7%8E%B0%E4%BB%A3-Cpp/" class="post-title-link" itemprop="url">第1章 迈向现代 C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-09 16:33:04 / Modified: 16:34:48" itemprop="dateCreated datePublished" datetime="2022-11-09T16:33:04+08:00">2022-11-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/Modern-C-Tutorial/" itemprop="url" rel="index"><span itemprop="name">Modern C++ Tutorial</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="第-1-章-迈向现代-c">第 1 章 迈向现代 C++</h1>
<ul>
<li>Use const char* and auto</li>
</ul>
<p>old: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> *str = <span class="string">&quot;hello world!&quot;</span>; <span class="comment">// 将出现弃用警告</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>Use noexcept</li>
</ul>
<p>C++98 异常说明、 unexpected_handler、set_unexpected() 等相关特性被弃用</p>
<ul>
<li>Use unique_ptr</li>
</ul>
<p>C++98 中的 auto_ptr 已被弃用</p>
<ul>
<li><p>如果一个类有析构函数，为其生成拷贝构造函数和拷贝赋值运算符的特性被弃用了。</p></li>
<li><p>use <code>static_cast</code> <code>reinterpret_cast</code> <code>const_cast</code></p></li>
</ul>
<p>C 语言风格的类型转换被弃用（即在变量前使用 (convert_type)），应该使用 static_cast、reinterpret_cast、const_cast 来进行类型转换。</p>
<h2 id="other">Other</h2>
<ul>
<li><p>C++ 不是 C 的一个超集</p></li>
<li><p>在编写 C++ 时，也应该尽可能的避免使用诸如 void* 之类的程序风格。</p></li>
<li><p>不得不使用 C 时，应该注意使用 extern "C" 这种特性，将 C 语言的代码与 C++代码进行分离编译，再统一链接这种做法，</p></li>
</ul>
<p>Ex: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// foo.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo.c</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;foo.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    [out = std::<span class="built_in">ref</span>(std::cout &lt;&lt; <span class="string">&quot;Result from C code: &quot;</span> &lt;&lt; <span class="built_in">add</span>(<span class="number">1</span>, <span class="number">2</span>))]()&#123;</span><br><span class="line">        out.<span class="built_in">get</span>() &lt;&lt; <span class="string">&quot;.\n&quot;</span>;</span><br><span class="line">    &#125;();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>先使用 gcc 编译 C 语言的代码： 编译出 foo.o 文件，再使用 clang++ 将 C++ 代码和 .o 文件链接起来（或者都编译为 .o 再统一链接）： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -c foo.c</span><br><span class="line">clang++ 1.1.cpp foo.o -std=c++2a -o 1.1</span><br></pre></td></tr></table></figure></p>
<p>Makefile: <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">C = gcc</span><br><span class="line">CXX = clang++</span><br><span class="line"></span><br><span class="line">SOURCE_C = foo.c</span><br><span class="line">OBJECTS_C = foo.o</span><br><span class="line"></span><br><span class="line">SOURCE_CXX = 1.1.cpp</span><br><span class="line"></span><br><span class="line">TARGET = 1.1</span><br><span class="line">LDFLAGS_COMMON = -std=c++2a</span><br><span class="line"></span><br><span class="line"><span class="section">all:</span></span><br><span class="line">	<span class="variable">$(C)</span> -c <span class="variable">$(SOURCE_C)</span></span><br><span class="line">	<span class="variable">$(CXX)</span> <span class="variable">$(SOURCE_CXX)</span> <span class="variable">$(OBJECTS_C)</span> <span class="variable">$(LDFLAGS_COMMON)</span> -o <span class="variable">$(TARGET)</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	rm -rf *.o <span class="variable">$(TARGET)</span></span><br></pre></td></tr></table></figure></p>
<h2 id="references">References</h2>
<p><a target="_blank" rel="noopener" href="https://changkun.de/modern-cpp/zh-cn/01-intro/">第 1 章 迈向现代 C++</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/08/Accelerated-Cpp-chapter10/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/08/Accelerated-Cpp-chapter10/" class="post-title-link" itemprop="url">Accelerated_Cpp_chapter10</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-08 01:02:45 / Modified: 01:04:35" itemprop="dateCreated datePublished" datetime="2022-11-08T01:02:45+08:00">2022-11-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">In</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/" itemprop="url" rel="index"><span itemprop="name">Cpp</span></a>
                </span>
                  , 
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Cpp/Accelerated-Cpp/" itemprop="url" rel="index"><span itemprop="name">Accelerated Cpp</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="managing-memory-and-low-level-data-structures">Managing memory and low-level data structures</h1>
<h2 id="pointers-to-functions">Pointers to functions</h2>
<p>Because all that you can do with a function is to take its address or call it, any use of a function that is not a call is assumed to be taking its address, even without an explicit &amp;.</p>
<h2 id="pointer-arithmetic">Pointer arithmetic</h2>
<p>In other words, suppose that <strong>a</strong> is an <strong>n</strong>-element array, that v is a vector, and that we wan to apply standard-library algorithms to elements of a. Then, wherever we might use <strong>v.begin()</strong> and <strong>v.end()</strong> to give standard-library algorithms access to elements of <em>v</em>, we should use <strong>a</strong> and <strong>a + n</strong> as arguments when we wish to apply these algorithms to the elements of <strong>a</strong>.</p>
<h2 id="char-array-and-a-pointer-to-a-char-array-in-main-function">char* array and a pointer to a char* array in main function</h2>
<p>Because "A+" is char array, and "A" is a pointer to char array. need char* to catch the return value of "A+".</p>
<p>char* array: <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> letters[] = &#123;</span><br><span class="line">    <span class="string">&quot;A+&quot;</span>, <span class="string">&quot;A&quot;</span>, <span class="string">&quot;A-&quot;</span>, <span class="string">&quot;B+&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;B-&quot;</span>, <span class="string">&quot;C+&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;C-&quot;</span>, <span class="string">&quot;D+&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;D-&quot;</span>, <span class="string">&quot;F&quot;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="get-array-size-use-sizeof">get array size use sizeof</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">double</span> numbers[] = &#123;</span><br><span class="line">    <span class="number">1.1</span>, <span class="number">2.2</span>, <span class="number">3.3</span>, <span class="number">4.4</span>, <span class="number">5.5</span>, <span class="number">6.6</span>, <span class="number">7.7</span>, <span class="number">8.8</span>, <span class="number">9.9</span></span><br><span class="line">&#125;</span><br><span class="line">std::<span class="type">size_t</span> size = <span class="built_in">sizeof</span>(numbers) / <span class="built_in">sizeof</span>(*numbers);</span><br></pre></td></tr></table></figure>
<p>this programs show main</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> fail_count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// for each file in the input list</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; argc; i ++) &#123;</span><br><span class="line">        <span class="function">ifstream <span class="title">in</span><span class="params">(argv[i])</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// if it exists, write its contents, otherwise generate an error message</span></span><br><span class="line">        <span class="keyword">if</span> (in) &#123;</span><br><span class="line">            string s;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">getline</span>(in, s)) &#123;</span><br><span class="line">                cout &lt;&lt; s &lt;&lt; endl;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cerr &lt;&lt; <span class="string">&quot;cannot open file &quot;</span> &lt;&lt; argv&#123;i] &lt;&lt; endl;</span><br><span class="line">            fail_count ++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fail_count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initializing-arrays-of-character-pointers">Initializing arrays of character pointers</h2>
<p>a string literal is just a convenient way of writing the address of the initial character of a null-terminated sequence of characters.</p>
<h2 id="ifstream-and-ofstream-are-kind-of-istream-and-ostream">ifstream and ofstream are kind of istream and ostream</h2>
<p>The standard library says exactly that, by defining <strong>ifstream</strong> to be a kind of <strong>istream</strong> and <strong>ofstream</strong> to be a kind of <strong>ostream</strong>. As a result, it is possible to use an <strong>ifstream</strong> wherever the library expects an <strong>istream</strong> and an <strong>ofstream</strong> wherever the library expects an <strong>ostream</strong> .</p>
<h2 id="file-name-need-a-pointer-to-the-initial-element-of-a-null-terminated-sequence-of-characters-character-array">file name need a pointer to the initial element of a null-terminated sequence of characters character array</h2>
<p><strong>C++11 could use string as name</strong> see <a target="_blank" rel="noopener" href="https://zh.cppreference.com/w/cpp/io/basic_ifstream/open">std::basic_ifstream</a></p>
<p>you could see this overload function <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">open</span><span class="params">( <span class="type">const</span> std::string &amp;filename,                                  </span></span></span><br><span class="line"><span class="params"><span class="function">           ios_base::openmode mode = ios_base::in )</span></span>;(<span class="number">3</span>)	(C++<span class="number">11</span> 起)</span><br></pre></td></tr></table></figure></p>
<p>When we define an <strong>ifstream</strong> or <strong>ofstream</strong> object, we might expect to have to supply, in the form of a <strong>string</strong> , the name of the file that we wish to use. In fact, we are required to supply, not a <strong>string</strong> , but rather a pointer to the initial element of a null- terminated character array. One reason for this curious requirement is to give programs the option of using the input-output library without using the <strong>string</strong> facilities. Another reason is historical: The input-output library predates the string class by several years. A third reason is that this requirement makes it easier to interface with operating-system input output facilities, which typically use such pointers to communicate. Whatever the reasons, the fact is that programs that deal with files must ultimately express the files' names as pointers to null-terminated character arrays.</p>
<h2 id="use-c_str-in-stringbefore-c11-c11-has-a-overload-function-for-string-as-name">use c_str in string(before C++11, C++11 has a overload function for string as name)</h2>
<p>If we don't want to have to give the name of the file as a literal, the best alternative is to store the file name in a <strong>string</strong> and then use the <strong>c_str</strong> member function.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string file = <span class="string">&quot;data.txt&quot;</span>;</span><br><span class="line"><span class="function">ifstream <span class="title">infile</span><span class="params">(file.c_str())</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="new-t-ex">new T[] Ex</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">char</span>* <span class="title">duplicate_chars</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// allocate enough space; remember to add onre for the null</span></span><br><span class="line">    <span class="type">size_t</span> length = <span class="built_in">strlen</span>(p) + <span class="number">1</span>;</span><br><span class="line">    <span class="type">char</span>* result = <span class="keyword">new</span> <span class="type">char</span>[length];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// copy into our newly allocated space and return pointer to first element</span></span><br><span class="line">    <span class="built_in">copy</span>(p, p + length, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/07/LeetCode-45-Jump-Game-II/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/LeetCode-45-Jump-Game-II/" class="post-title-link" itemprop="url">LeetCode 45. Jump Game II</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-07 09:29:18" itemprop="dateCreated datePublished" datetime="2022-11-07T09:29:18+08:00">2022-11-07</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-11-08 01:05:08" itemprop="dateModified" datetime="2022-11-08T01:05:08+08:00">2022-11-08</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="leetcode-45.-jump-game-ii">LeetCode 45. Jump Game II</h1>
<h2 id="main-idea">Main Idea</h2>
<p>[2, 3, 1, 1, 4]</p>
<p>等价于2往3和1连了条有向边，3往1, 1, 4, 连了条有向边，1往4连了条有向边，4往空连了条有向边。</p>
<p>这样就变成了一个有向图，求从2到4的最短路径。</p>
<p>最坏情况下，每个点都往后面所有点连了一条有向边，这样就变成了一个完全图</p>
<p>边数n^2, 时间复杂度O(n^2)</p>
<p>优化图可以用dp</p>
<p>最短路径最小规模的表示可以为0-&gt;2 加上2到终点的距离</p>
<p>那状态定义为f[i]表示从i到终点的最短路径</p>
<p>倒推可以得到f[0]</p>
<p>但是这样也是O(n^2)的时间复杂度</p>
<p>估计需要找个单调的性质来再优化</p>
<p>通过归纳可以得知，从小到大遍历过程中，第一次通过 x 可以到达 y 时，y 的最少步数就是 x 的最少步数加 1。因为一次移动，可以从 x 到 [x+1,x+nums(x)]] 的任意位置，所以根据归纳（即 xx 也是这样到达的），这样一定是最优的。</p>
<p>重新定义f(i): 设状态 f(i) 表示从起点到达 i 所需要的最少步数。</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">jump</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">f</span><span class="params">(n)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j + nums[j] &lt; i) j ++;</span><br><span class="line">            f[i] = f[j] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/07/LeetCode-44-Wildcard-Matching/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="krmmzs">
      <meta itemprop="description" content="233">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="krmmzs">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/07/LeetCode-44-Wildcard-Matching/" class="post-title-link" itemprop="url">LeetCode 44. Wildcard Matching</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>
              

              <time title="Created: 2022-11-07 08:42:00 / Modified: 09:25:55" itemprop="dateCreated datePublished" datetime="2022-11-07T08:42:00+08:00">2022-11-07</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="leetcode-44.-wildcard-matching">LeetCode 44. Wildcard Matching</h1>
<h2 id="main-idea">Main Idea</h2>
<p>和第十题一样</p>
<p>f(i, j) 表示 s 的前 i 个字符和 p 的前 j 个字符是否匹配</p>
<p>状态转移看当前的字符是什么</p>
<ol type="1">
<li>p[j] is '*'</li>
<li>p[j] is not '*' s[i] == p[j] &amp;&amp; f(i - 1, j - 1)</li>
</ol>
<p>p[j] is '*' 情况有很多，匹配0个就是由f(i, j - 1)推来，匹配1个就是由f(i - 1, j - 1)推来，匹配2个就是由f(i - 2, j - 1)推来，匹配3个就是由f(i - 3, j - 1)推来，匹配4个就是由f(i - 4, j - 1)推来，匹配5个就是由f(i - 5, j - 1)推来，匹配6个就是由f(i - 6, j - 1)推来，匹配7个就是由f(i - 7, j - 1)推来，匹配8个就是由f(i - 8, j - 1)推来，匹配9个就是由f(i - 9, j - 1)推来，匹配10个就是由f(i - 10, j - 1)推来，匹配11个就是由f(i - 11, j - 1)推来，匹配12个就是由f(i - 12, j - 1)推来，匹配13个就是由f(i - 13, j - 1)推来，匹配14个就是由f(i - 14, j - 1)推来，匹配15个就是由f(i - 15, j - 1)推来，匹配16个就是由f(i - 16, j - 1)推来，匹配17个就是由f(i - 17, j - 1)推来，匹配18个就是由f(i - 18, j - 1)推来，匹配19个就是由f(i - 19, j - 1)推来，匹配20个就是由f(i - 20, j - 1)推来，匹配21个就是由f(i - 21, j - 1)推来，匹配22个就是由f(i - 22, j - 1)推来 以此类推</p>
<p>此时状态数量n^2, 转移数量n, 所以时间复杂度是O(n^3)</p>
<p>然后利用完全背包的优化方式优化</p>
<p>f(i, j), f(i, j - 1), f(i, j - 2), f(i, j - 3), f(i, j - 4)... f(i - 1, j), f(i - 1, j - 1), f(i - 1, j - 2), f(i - 1, j - 3), f(i - 1, j - 4)... 替换得到 f(i, j) = f(i - 1, j - 1) | f(i - 1, j)</p>
<p>转移方程变成了O(1)</p>
<h2 id="code">Code</h2>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isMatch</span><span class="params">(string s, string p)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = s.<span class="built_in">size</span>(), m = p.<span class="built_in">size</span>();</span><br><span class="line">        s = <span class="string">&#x27; &#x27;</span> + s, p = <span class="string">&#x27; &#x27;</span> + p;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">f</span>(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(m + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        f[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; i ++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; j ++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j] == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    f[i][j] = f[i][j - <span class="number">1</span>] || i &amp;&amp; f[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    f[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; i &amp;&amp; f[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">krmmzs</p>
  <div class="site-description" itemprop="description">233</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">69</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">40</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/krmmzs" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;krmmzs" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:belliyan250@gmail.com" title="E-Mail → mailto:belliyan250@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://www.youtube.com/channel/UCh2c-Y0OmoDUfeZHomm_Llg" title="YouTube → https:&#x2F;&#x2F;www.youtube.com&#x2F;channel&#x2F;UCh2c-Y0OmoDUfeZHomm_Llg" rel="noopener" target="_blank"><i class="fab fa-youtube fa-fw"></i>YouTube</a>
      </span>
      <span class="links-of-author-item">
        <a href="https://t.me/krmmzs" title="Telegram → https:&#x2F;&#x2F;t.me&#x2F;krmmzs" rel="noopener" target="_blank"><i class="fab fa-telegram fa-fw"></i>Telegram</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">krmmzs</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

  

</body>
</html>
